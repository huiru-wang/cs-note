# JVM 优化核心

1、提升对象从年轻代进入老年代的门槛；

2、降低 FullGC 次数；(核心)

# FullGC 触发原因

# 常见优化原则

1、尽可能将新对象留在年轻代，并提高进入老年代门槛；

- `-XX:PetenureSizeThreshold`：默认 15，超出此阈值，对象移入老年代；
- `-XX:TargetSurvivorRatio=90`：Survivor 区占用达到 90%，再将对象移入老年代

  提高 Survivor 区的利用率；

2、大对象应该直接进入老年代

大对象仍然创建在年轻代，对 MinorGC 也是一种压力；

如果占用空间很多，即使 gc 年龄很小，也会被很快移入老年代，不如直接分配在老年代

`-XX:PetenureSizeThreshold`：如果对象大小超过这个值，将直接分配在老年代

3、尽可能固定堆的大小，可以减少 GC 频率；

如果-Xms 小于-Xmx，堆会尽可能维持在较小的大小，并且有两个参数，会根据堆的空闲比例，对堆空间进行扩展、压缩；

- `-XX:MinHeapFreeRatio`：最小空闲比例，超出，扩展堆；
- `-XX:MaxHeapFreeRatio`：最大空闲比例，超出，压缩堆；

如果`-Xms == -Xmx`，可以获得一个较为稳定的堆，并且上面的两个参数自动失效；

4、根据场景，选择合适的垃圾收集器

重视响应速度、交互的用户体验：

- ParallelNew + CMS(应用内存占用不大，可以用 CMS)
- G1(应用需要大内存、G1 会比 CMS 好)

重视计算，而非交互型的低延迟：

- Parallel Scavenge + Parallel Old

## 年轻代内存优化方向

年轻代优化需要考虑两个问题：
1、年轻代如果内存过小，就会导致很容易满，幸存对象更容易进入老年代，给 FullGC 带来压力；

2、年轻代如果内存过大，就会影响复制算法的效率；

因此需要选择合适的年轻代大小；

# JVM 优化常见问题

## FullGC 释放内存不大

考虑：内存泄漏，存在无法回收，又不使用的对象；

## FullGC 频繁

## FullGC 耗时过长