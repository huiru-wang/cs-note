

# RPC实现

可以基于TCP、UDP、也可以基于Http


# RPC对比HTTP

1、**数据传输**


且HTTP1.1的header是使用的文本编码，占用容量大；并且body通常使用JSON格式，额外的空间占用较大；

TCP的报文可以做到很小，因此大部分高效的RPC通信都是基于TCP进行定制化，甚至于UDP；如：protobuf、Hessian等都是用二进制数据格式，更小，更快；

不过GPRC是基于HTTP2.0的，HTTP2.0已经解决了HTTP1.1的报文编码问题；

2、**定制化能力**

HTTP协议中的报文为了通用性，兼顾了很多后端通信不需要的信息，有效信息占比少；并且数据为文本格式，无类型，当进行服务级别的通信时，必然涉及到反射进行统一处理，性能会比较差；

而RPC基于TCP进行服务级别的定制化，使用效率更高的序列化方式；如：GRPC中不同语言之间转换为protobuf并且保留类型信息；序列化之后数据很小，不需要反射进行反序列化，性能好；

3、**封装性更好**

在系统层面，进行远程过程调用时，如果使用HTTP，难免需要配置管理业务之外的连接问题：URL、请求方式、请求头等；

而RPC的封装性更好，使用服务提供方的封装好的接口即可，更好地专注于业务；

并且可以封装提供额外的机制：重试机制、负载均衡等等；

同时还有一个好处：提高开发效率；不关注通信细节，只关注业务；

4、HTTP优势：
- 可以适用于各种场景；不需要额外依赖；
- 统一化、规范化；
# RPC心跳方案

1、借助传输层的TCP KeepAlive保活机制；
- 上层不需要关注，内核实现；
- 只能判断对方是否存活，不能判断是否服务可用等信息；只能解决传输层的问题；
  
2、应用层自行实现心跳检测；
- 应用层自行实现，灵活，可以加入应用层业务逻辑；

3、TCP KeepAlive + 应用层心跳；
- Dubbo的心跳方案：[Dubbo-心跳方案](https://cn.dubbo.apache.org/zh-cn/blog/2018/08/19/dubbo-%e7%8e%b0%e6%9c%89%e5%bf%83%e8%b7%b3%e6%96%b9%e6%a1%88%e6%80%bb%e7%bb%93%e4%bb%a5%e5%8f%8a%e6%94%b9%e8%bf%9b%e5%bb%ba%e8%ae%ae/)
