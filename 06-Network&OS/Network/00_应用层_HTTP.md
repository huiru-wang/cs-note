- [HTTP特点](#http特点)
- [HTTP演进](#http演进)
  - [HTTP 1.0（废弃）](#http-10废弃)
  - [HTTP 1.1（使用广泛）](#http-11使用广泛)
    - [缺陷](#缺陷)
  - [HTTP 2](#http-2)
    - [多路复用](#多路复用)
    - [流量控制窗口](#流量控制窗口)
    - [HTTP3](#http3)
- [一次完整的HTTP请求](#一次完整的http请求)
  - [1. 域名解析](#1-域名解析)
  - [2. 建立TCP连接](#2-建立tcp连接)
  - [3. 客户端发送HTTP请求](#3-客户端发送http请求)
  - [4. 服务端响应数据](#4-服务端响应数据)
  - [5. 浏览器解析渲染](#5-浏览器解析渲染)
  - [6. 浏览器渲染HTML](#6-浏览器渲染html)
  - [7.服务端关闭TCP连接](#7服务端关闭tcp连接)
- [HTTP会话机制](#http会话机制)
- [Cookie](#cookie)
  - [Cookie设置和使用](#cookie设置和使用)
- [HTTP连接管理](#http连接管理)
  - [短连接](#短连接)
  - [长连接](#长连接)
  - [管道](#管道)
- [常用HTTP状态码](#常用http状态码)
  - [重定向](#重定向)
  - [权限相关](#权限相关)
  - [服务端错误](#服务端错误)

# HTTP特点
1、请求应答模式：要什么给什么；

2、灵活可扩展：Header多种多样、可以任意约定，请求响应体等都可以自定义内容；

3、可靠传输：基于TCP协议；

4、无状态：任意一次Http请求都是独立的，不记录状态；由Cookie/Session进行状态管理；

# HTTP演进
![loadingag5090](../images/httpversion.png?msec=1678122904004)

## HTTP 1.0（废弃）
- 无状态：不跟踪不记录请求的状态；
- 无连接：每次请求都需要建立连接（不支持长连接）；
- 队头阻塞：请求全部同步处理，处理请求后，发送响应，接受到ACK，再处理下一个请求；
- 端口易耗尽：主动断开一方，必须经过2个MSL的TIME_WAIT状态；
- 仅支持文本内容；不支持图片、视频；

## HTTP 1.1（使用广泛）

- 默认长连接：增加了Connection，设置为keep-alive保持长连接；默认保持
- 管道化技术：将多个请求通过一个TCP连接发送，**但是响应仍要顺序接收，不解决对头阻塞**；
- 缓存：允许浏览器缓存响应，在资源无变化的情况下，可以直接使用缓存；缓存有失效时间；
- 断点续传：增加Header
- 支持图片、视频、音频；

：（总体缺陷：高延迟）

### 缺陷

1、**对头阻塞：同一个HTTP连接内，响应会按顺序处理，无法乱序，出现丢包，后续响应不会处理**；

为了能够并发处理多个资源的响应，在开发层面就出现了很多操作：
- 使用雪碧图将多个图标合成一个请求；
- 又比如将图片以Base64放入Html中，一起发送；但一般不这么做，代码太长了；不好管理；

2、连接利用率低

浏览器限制同一个域下的连接数，一般为6个连接；再加上队头阻塞，对于HTTP连接的利用率就很低，如果发生丢包，非常影响页面渲染速度；

因此很多站点使用CDN，或者在同一个站点下，建立多个域，来并发多个HTTP请求静态资源；

3、请求头重复累赘：每次都要发冗长的Cookie；且只支持Body压缩，Header数据无压缩；

## HTTP 2

HTTP2就是为了解决HTTP1.1的痛点，在HTTP1.1基础上新增特性；
- **二进制帧**：HTTP2将原来的报文中的Header和Body变为`首部帧`和`数据帧`，以**二进制的格式传输**；
- **流标识符**：每个二进制帧都有一个流标识符，可以乱序接收响应，再通过流标识符进行整合；(**解决了应用层面的队头阻塞，无法解决TCP的队头阻塞**)
- **头部压缩**：使用HPack压缩头部；
- **安全性增强**：HTTP2基于HTTPS，加密传输;
- **主动推送**：在客户端请求资源时，如发现一些连带的资源会主动推送给客户端，如：css、js等资源；

### 多路复用

在二进制帧和流标识符的基础上，HTTP2就可以在同一个HTTP连接中并发处理请求响应，即多路复用；

### 流量控制窗口


### HTTP3

HTTP2主要问题出在TCP上，TCP是内核实现，短时间无法解决；
- TCP的三次握手冗余；TLS的握手已经可以完成连接建立了；
- TCP的慢启动；
- TCP的队头阻塞：TCP只知道要按顺序接收数据，发现丢包不会将后续的数据返回给应用层；必须要重传；

因此HTTP3使用UDP，并且在应用层实现QUIC协议整合了TLS，TCP的功能被上移至QUIC协议实现；以此来解决TCP的队头阻塞；

应用层数据被封装成QUIC帧，最终以UDP数据段的形式发送；

# 一次完整的HTTP请求

## 1. 域名解析

- 首先浏览器搜索自身的DNS缓存
  
- 如果浏览器没有缓存,则会搜索系统的DNS缓存
  
- 如果还没有,就从hosts文件中找
  
- 还没有,就递归地去域名服务器查找；
  

## 2. 建立TCP连接

三次握手，建立成功后，客户端才能发送Http请求

## 3. 客户端发送HTTP请求

客户端发送HTTP请求到服务端；

## 4. 服务端响应数据

HTTP响应也由三部分组成：状态码，响应头和实体内容  
- 状态码  
- 若干响应头  
- 实体内容

## 5. 浏览器解析渲染

览器拿到html文件后，就开始解析其中的html代码  

遇到js/css/image等静态资源时，就向服务器端去请求下载  

此时就需要用到Connection:keep-alive特性了,建立一次连接,就可以请求多个资源  

针对每个资源, 进行多线程请求, 页面显示顺序不一定按照代码顺序执行

## 6. 浏览器渲染HTML

浏览器是一个边解析边渲染的过程

- 首先浏览器解析HTML文件构建DOM树
  
- 然后解析CSS文件构建渲染树
  
- 等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上

JS的解析是由浏览器中的JS解析引擎完成的，JS是单线程运行，有可能修改DOM结构，  

## 7.服务端关闭TCP连接 

HTTP1.1会默认保持连接；

# HTTP会话机制
HTTP是无状态协议，每一次请求都是独立的，不记录状态；因此服务端要想保持状态，就需要额外的会话机制；
- Cookie
- Session

# Cookie
- Cookie由明文存储，公开，可修改；
- Cookie由Key-Value构成；
    - expires：绝对的过期时间；不设置expires，关闭浏览器则失效；
    - max-age：Cookie最长存活时间(秒)；
    - domain：当前Cookie所属域名；(<font class="font-pink">浏览器来保证禁止Cookie跨域</font>)
    - path：可以使用此Cookie的路径；
    - httponly：不允许脚本修改Cookie；
- Cookie的安全、过期、跨域校验等都由浏览器保证；
- Cookie存储：带有expires保存在磁盘中；不带有expires则临时放在内存；
- Cookie大小：受限于使用的浏览器；
- 大多数网站的保持登录功能由Cookie实现，Cookie被窃取，则大概率可直接进行登录(Cookie-Editor)；

## Cookie设置和使用
两个Header：
- Set-cookie：首次访问服务端时，服务端设置；
- Cookie：后续保持状态请求服务端时，携带Cookie；
# HTTP连接管理
## 短连接

HTTP1.0的默认连接模型：每一次HTTP请求，都进行一次TCP握手；
- 创建连接耗时；
- TCP的冷启动效率低下；

## 长连接
HTTP1.1后默认长连接(不需要设置)：保持一段连接，重复使用；
- 空闲一段时间被关闭，由Keep-Alive指定；
- 

## 管道

# 常用HTTP状态码
## 重定向
尽量使用301，可以防止重定向的地址被劫持；

**301：永久重定向**；原地址A返回301，并使用Location指向B资源；**浏览器会记住这个重定向，下次访问相同的原地址， 则直接重定向，不会再请求服务端**；
```
HTTP/1.1 301 Moved Permanently
Location: http://www.example.org/index.asp
```
- 原本的URL已经无法使用，或希望被替换掉(比如404页面)

**302：临时重定向**；原地址A返回302，并使用Location指向B资源；**浏览器不会记住它，下次依然先请求服务端，因为每次重定向都是临时的**；
```
HTTP/1.1 302 Found
Location: http://www.example.org/index.asp
```
- 搜索引擎友好，可能会被URL劫持；

## 权限相关

401：客户端鉴权失败；
```
401 Unauthorized
```

403：客户端错误，通常是客户端对此资源无权限；
```
403 Forbidden
```

## 服务端错误

500：服务端错误；

502：网关路由失败；无法响应；

504：网关获取后端服务响应超时；