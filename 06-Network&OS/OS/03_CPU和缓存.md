- [CPU架构](#cpu架构)
- [缓存行](#缓存行)
  - [伪共享问题](#伪共享问题)
  - [缓存行填充](#缓存行填充)
- [多核缓存一致性问题](#多核缓存一致性问题)
  - [1. 总线锁(缓存行锁)](#1-总线锁缓存行锁)
  - [2. 缓存一致性协议](#2-缓存一致性协议)
    - [缓存一致性协议特性](#缓存一致性协议特性)
- [MESI](#mesi)
  - [缓存行的四种状态](#缓存行的四种状态)
  - [总线嗅探机制](#总线嗅探机制)
  - [StoreBuffer/InvalidQueue](#storebufferinvalidqueue)
  - [内存屏障](#内存屏障)

# CPU架构
<div align="center">
<img src="../images/cpu-cache.png" alt="concurrency"/>
</div>

1、单个CPU内含有多个核；

2、每个CPU含有一个L3缓存；每个核有独占的L1、L2缓存；弥补主存和CPU的性能差距；同时带来了缓存不一致的问题；

# 缓存行
CPU以`行`为单位读取缓存数据，来提高吞吐量；一行数据的大小由CPU架构决定：32字节、64字节；

## 伪共享问题
同一个缓存行，含有两个变量，被两个CPU读取，其中一个变量被修改，导致另一个CPU的缓存行失效；
- 会降低CPU的并发性能；

## 缓存行填充
缓存行的填充有两个应用：

1、充分利用缓存行大小：同一个对象的字段，尽可能优先按缓存行大小排序；

2、解决伪共享问题(空间换时间)：同一行进存储目标变量，多出来的空间填充零；

# 多核缓存一致性问题
缓存一致性协议：为了解决并发场景下，CPU不同核心使用的共享缓存的一致性问题：

解决缓存一致性问题，有两个办法：

## 1. 总线锁(缓存行锁)

总线锁：

缓存行锁：只锁缓存行，当要锁的数据大于缓存行，则会变成总线锁；

**JMM的 `volatile` 是通过 `lock` 指令，实现的缓存行锁，而非MESI**

## 2. 缓存一致性协议

多个CPU间需要遵循一致性协议，来保证操作共享内存时缓存一致；

当某个核心触发了写操作，会在总线中进行通知，其他监听此缓存行的线程就会对自己持有的副本进行失效处理；因此缓存一致性协议也叫写失效协议；

常见的缓存一致性协议的实现是：MSI、MESI、MOSI；
  
### 缓存一致性协议特性
1、缓存一致性协议是无锁的；

2、**缓存一致性协议是硬件级别实现的，无法通过软件指令开启或关闭**；也不存在什么指令能够针对某个缓存行开启缓存一致性保证；(volatile也不行)

3、**缓存一致性协议是弱一致性协议；只能保证顺序一致性，是指令的先发生后发生问题，并不能保证并发场景下的程序正确性，就如同有序性并不能保证原子性；因此不能解决并发安全问题；**

# MESI
**动画演示MESI：[MESI Help](https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm)**

MESI特点：
- MESI是默认生效的；
- MESI


## 缓存行的四种状态

**Modified**: 标识缓存行已被修改；

**Exclusive**：标识缓存行是独占的；

**Shared**：标识缓存行是共享的；

**Invaild**：标识缓存行已失效；

## 总线嗅探机制

嗅探机制：CPU在进行读写操作时，根据缓存行的当前状态，同时监听其他CPU操作此缓存行的行为；

当某个线程触发了写操作，会在总线中进行通知，其他监听此缓存行的线程就会对自己持有的副本进行失效处理；

以某一CPU视角，解释嗅探运作机制：
- 当前缓存处于`Modified`状态时，监听到其他CPU对主内存此缓存的读操作时，立即将此CPU的缓存写回主内存；
- 当前缓存处于`Exclusive`状态时，监听到其他CPU对主内存此缓存的读操作时，立即将此CPU的缓存标记为Shared状态；
- 当前缓存处于`Shared`状态时，监听到其他CPU对主内存此缓存的写操作时，立即将此CPU的缓存标记为Invalid；
- 当前缓存处于`Invalid`状态时，立即从内存中重新读取；

嗅探机制会对变量的读写执行额外的操作：
- 写操作：只能写M、S的缓存；并且写操作之后，会对其他CPU的此缓存进行失效操作；
- 读操作：只能读M、E、S缓存；

## StoreBuffer/InvalidQueue

Store Buffer和Invalid Queue是为了解决MESI协议的效率问题而出现的；

![](../images/mesi.png)

## 内存屏障

内存屏障是为了解决 store buffer 和 invalidate queue 带来的全局顺序性问题；

