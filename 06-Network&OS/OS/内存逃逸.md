

# 内存逃逸
程序中最高效的内存结构是：栈

内存逃逸：当编译器无法保证一个变量的声明周期只在当前的函数内时，就会将其分配到**堆**中，以保证函数返回，栈帧回收后，此变量仍然有效；
- 闭包是一个典型的内存逃逸情况；

内存逃逸影响：栈内存是没有回收的，直接释放，速度很快，当发生内存逃逸，分配在对上，就需要依靠GC来回收，会增加GC的压力；

# 内存逃逸场景

1、超出栈的大小，只能分配到堆上；

2、闭包；

3、golang中入参为不确定类型，如：interface；函数无法确定其大小，全都会逃逸，分配在堆上；

4、函数内创建的对象，被堆上对象引用；

# 逃逸分析

1、JVM的JIT动态编译代码时，会进行逃逸分析，如果对象没有逃逸，则不会分配到堆上；

JDK1.7之后，逃逸分析是默认开启的；