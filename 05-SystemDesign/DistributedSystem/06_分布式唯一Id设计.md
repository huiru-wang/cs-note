- [什么情况下我们需要ID生成器](#什么情况下我们需要id生成器)
- [ID生成器设计目标](#id生成器设计目标)
- [常见ID生成方案](#常见id生成方案)
  - [1. 数据库自增列](#1-数据库自增列)
  - [2. UUID](#2-uuid)
  - [3. 雪花算法](#3-雪花算法)
  - [4. Redis生成ID](#4-redis生成id)


# 什么情况下我们需要ID生成器

- 数据库水平拆分的情况下，主键由于需要作为业务标识使用，需要唯一；
- 业务编号需要暴露给用户，希望隐藏业务信息，可以使用非业务相关的唯一Id；
- 业务编号需要体现业务信息，可以使用渠道、时间等业务相关信息拼成的唯一Id；

# ID生成器设计目标

- 唯一性：分布式全局唯一（必须）
- 高性能：业务强相关需要考虑性能；
- 递增性：趋于递增，对索引友好，插入性能好，每次在尾部页插入，不需要移动别的数据；

> 如UUID：InnoDB每个页大小固定，如果id乱序，在插入时，可能使得页内的其他数据需要移动到别的页；影响性能；
 
- 扩展性：分布式场景，需要支持分库分表扩展，不能有主键冲突，同时也要满足负载均衡，不应该有热点效应；

> 主键Id的扩展性会比较差，如果分表同时写入，可能主键冲突；如果水平分表，有尾部热点效应，无法负载均衡；

# 常见ID生成方案

## 1. 数据库自增列

可以通过设置bigint类型的数据库自增列，在事务中

优点：简单，不借助外部组件；

缺点：水平扩展困难，分库分表存在主键冲突；

## 2. UUID

生成的是字符串，没有业务含义；无法递增，存数据库比较占用空间；

优点：本地生成，没有网络消耗，可以任意水平扩展

缺点：占内存，无序插入效率低；

## 3. 雪花算法
snowflake是Twitter开源的分布式ID生成算法，是一个long型的ID

核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。

![img](https://box.kancloud.cn/4f49804e02d591599ae3aac8f1f10e32_1021x346.png)

| 分段  | 作用               | 说明                                         |
| :---- | :----------------- | :------------------------------------------- |
| 1bit  | 保留               | —                                            |
| 41bit | 时间戳，精确到毫秒 | 可以支持69年的跨度                           |
| 10bit | 机器编号           | 支持分布式扩展，保证分布式节点生成id的唯一性 |
| 12bit | 毫秒内的计数       | 保证节点内id的顺序性                         |

**优点**：id具备递增性，效率高，扩展性强；

**缺点**：强依赖服务器始终，id中有41bit都依赖时间戳；时钟回拨则可能出现重复id；

## 4. Redis生成ID

当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。

依赖：INCR和INCRBY来实现。

可以使用Redis集群来获取更高的吞吐量。

假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5：
```
A：1,6,11,16,21
B：2,7,12,17,22
C：3,8,13,18,23
D：4,9,14,19,24
E：5,10,15,20,25
```

比较适合使用Redis来生成每天从0开始的流水号。比如`订单号 = 日期 + 当日自增长号`；

可以每天在Redis中生成一个Key，使用INCR进行累加。

**优点**：性能优于数据库，有排序性，且具备扩展性；

**缺点**：引入Redis组件，还需要维护Redis的高可用，需要额外编码工作；步长确定难以修改；
