- [分布式锁设计原则](#分布式锁设计原则)
	- [1. 锁在分布式场景下是全局单例的](#1-锁在分布式场景下是全局单例的)
	- [2. 排他锁/唯一性](#2-排他锁唯一性)
	- [3. 可重入](#3-可重入)
	- [4. 锁失效机制：避免死锁/业务续费](#4-锁失效机制避免死锁业务续费)
		- [相关实现](#相关实现)
	- [5. 锁粒度尽可能小/持锁时间尽可能短](#5-锁粒度尽可能小持锁时间尽可能短)
	- [6. 锁性能](#6-锁性能)
	- [7. 集群场景高可用性—CP/AP模型](#7-集群场景高可用性cpap模型)
	- [8. 阻塞/非阻塞](#8-阻塞非阻塞)
	- [9. 公平锁/非公平锁](#9-公平锁非公平锁)
	- [10. 读写锁](#10-读写锁)
- [死锁](#死锁)
	- [死锁检测](#死锁检测)
- [分布锁实现](#分布锁实现)
	- [1. DB](#1-db)
	- [2. Redis](#2-redis)
	- [3. ETCD](#3-etcd)
	- [4. Zookeeper](#4-zookeeper)

# 分布式锁设计原则
## 1. 锁在分布式场景下是全局单例的
- DB唯一约束的记录；
- Redis唯一key；

## 2. 排他锁/唯一性
保证同时只有一个线程持有锁；

## 3. 可重入
允许已经持锁线程，可以再次获取锁：比如递归调用；
- 设置线程的**唯一标识**，并**记录重入次数**；
- 每次释放，重入次数减一；

## 4. 锁失效机制：避免死锁/业务续费

1、设置超时时间，防止持锁节点宕机；在限定时间未释放锁，即认为锁失效；

2、业务执行时间不好把控，当业务执行稍长，需要给锁续费；

因为锁的超时时间的设置，就不好把控；不同的组件有不同的策略：

### 相关实现
1、Redisson：Watch Dog；
- 开启异步任务，定时续费；
- 当释放锁，同步删除异步续费任务；

2、ETCD Watch机制

3、Zookeeper Zab算法；

## 5. 锁粒度尽可能小/持锁时间尽可能短
降低持锁时操作的复杂度，尽可能需要锁的时候才加锁；
尽可能提高并发性能；

## 6. 锁性能
选用性能更佳的中间件；
Redis  > ETCD > Zookeeper > DB

## 7. 集群场景高可用性—CP/AP模型
涉及到集群，就要涉及数据的一致性问题；
通常写操作由主节点完成，再同步到从节点，保证高可用；

但是同步过程总是有延迟，极低概率出现**写入后，未同步完成，主节点宕机**的情况，导致锁丢失问题；

AP/CP模型考虑：
- 优先保证数据一致性，就要优先考虑==CP模型==(一致性优先)
	- zookeeper (zab协议)
	- etcd (Raft算法)
- 优先考虑性能，考虑==AP模型==(可用性优先)
	- Redis (RedLock)
因此AP模型就要对数据一致性多做一些特殊保证；如Redis的红锁算法；
[[Cache/Redis/10_Redis-分布式锁#RedLock|Redis-分布式锁-RedLock]]

## 8. 阻塞/非阻塞

非阻塞：多数情况下，分布式锁都是非阻塞的；

阻塞：Redis

1、非阻塞式：直接使用Redis原生命令，判断key是否存在即可；

2、阻塞式：需要感知到获取锁失败，感知到资源正在被其他任务执行；可以使用**Redis的发布订阅模式**，如果未获取到锁，进入等待队列，当收到锁释放通知，唤醒等待队列的线程；

## 9. 公平锁/非公平锁

是否公平，并不是分布式锁的必要条件；可以是额外扩展功能；普遍情况下都是非公平的；

Redisson实现了公平锁；

## 10. 读写锁


# 死锁

死锁原因：2个线程互相占用对方等待的临界资源，又不释放当前占用的临界资源；
- 资源都是互斥的；
- 

## 死锁检测
解决死锁的代价比较高，大多数操作系统都不会提供死锁检测；

TODO

# 分布锁实现

## 1. DB
依赖MySQL的唯一索引设计分布式锁；
- 通过唯一索引，做插入操作；实现排他性；
- 记录线程唯一标识，记录重入次数，实现可重入；
- 设置失效时间；超时则认为释放；

## 2. Redis

- AP架构；集群下不能保证锁的唯一性；Redis官方RedLock可以保证，复杂度高；
- 非阻塞分布式锁；

## 3. ETCD

- CP架构；Raft算法保证一致性；

## 4. Zookeeper
[Zookeeper分布式锁](https://pdai.tech/md/arch/arch-z-lock.html#%E5%9F%BA%E4%BA%8Ezookeeper%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81)

- CP架构；Zab协议保证一致性；

1、使用 ZK 的临时节点和有序节点，每个线程获取锁就是在 ZK 创建一个`临时有序的节点`，比如在 /lock/ 目录下。

2、创建节点成功后，获取 /lock 目录下的所有临时节点，再判断当前线程创建的节点是否是`所有的节点的序号最小的节点`。

3、如果当前线程创建的节点是`所有节点序号最小的节点`，则认为`获取锁成功`。

4、如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的 前一个节点 添加一个`事件监听`。

缺点：

1、羊群效应；当节点变化，可能触发大量的监听，导致集群响应变慢；

2、zk读写吞吐量不高；