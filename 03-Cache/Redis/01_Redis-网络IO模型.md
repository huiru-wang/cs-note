- [IO模型](#io模型)
- [单Reactor单线程模型](#单reactor单线程模型)
- [主从Reactor模型](#主从reactor模型)
- [后台线程](#后台线程)
- [Redis高性能](#redis高性能)
  - [1. 纯内存访问](#1-纯内存访问)
  - [2. I/O多路复用](#2-io多路复用)
  - [3. 高效数据结构](#3-高效数据结构)
- [多线程版本演进](#多线程版本演进)
  - [Redis6.0](#redis60)

# IO模型

IO模型：事件驱动的IO多路复用模型；通过一个循环不断捕获事件、分发事件；主要处理的事件有：**连接事件、读事件、写事件**；

- Redis每个客户端都有一个指令队列，同一队列的指令顺序执行，响应类似；
- 不同队列之间由Redis的单线程Epoll多路复用切换处理；
- 一个Redis实例同一时刻只会处理一个命令或响应；

# 单Reactor单线程模型
Redis6.0之前，使用单Reactor单线程模型；使用单线程处理连接事件、读事件、写事件；
- 连接事件由Acceptor处理；
- 读写事件由对应的Read/Write Handler处理；

# 主从Reactor模型

Redis6.0之后，使用多Reactor多线程模型；

- 主Reactor：监听socket、处理连接事件、执行命令；
- 多线程：负责解析读事件中的命令，将命令结果写回socket；

主Reactor处理连接事件，收到读事件后，将其分发给其他线程来解析命令，解析完成，放入队列中，交给主线程执行命令；执行完成，分发给其他线程，将数据写回socket；


# 后台线程

- bgrewriteaof：AOF重写子进程；
- bgsave：RDB后台子进程；
- Lazy Free线程：异步删除key；(Redis4.0)

# Redis高性能

**执行命令是纯内存操作，不涉及IO操作，使用单线程处理不会成为性能瓶颈，并且能够保证原子性；而读写等IO操作使用多线程执行；**

## 1. 纯内存访问

正是因为Redis是基于内存，CPU不是限制Redis速度的瓶颈，IO处理是限制Redis的瓶颈，所以直接执行命令的操作采用单线程即可，而且能够保证原子，实现简单；

## 2. I/O多路复用

采用非阻塞I/O的Epoll多路复用技术：让单线程处理多个连接请求；

多路-指的是多个socket连接，复用-指的是复用一个线程

## 3. 高效数据结构

SDS、Zset；

# 多线程版本演进
Redis4.0之前全部任务单线程处理；

Redis4.0：命令的读写、解析、执行为单线程，在处理慢操作时，启动后台线程异步处理；如：unlink大Key删除；

## Redis6.0

使用单线程 + 多进程的方案；默认禁用多线程；

Redis单机可达 8-10w QPS；若想要支持更高的QPS，瓶颈主要在于网络IO的处理；

Redis6中执行命令仍使用单线程，处理网络IO的读写使用多线程；