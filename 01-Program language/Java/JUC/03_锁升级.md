- [Mark Word](#mark-word)
- [JIT对锁的优化](#jit对锁的优化)
  - [锁消除](#锁消除)
  - [锁粗化](#锁粗化)
- [锁升级过程](#锁升级过程)
  - [锁升级](#锁升级)
  - [偏向锁](#偏向锁)
    - [偏向锁的代价](#偏向锁的代价)
  - [轻量级锁](#轻量级锁)
  - [重量级锁](#重量级锁)

# Mark Word
**锁状态**：无锁、偏向锁、轻量级锁、重量级锁（**具体是何种状态，取决于竞争情况**）

HotSpot虚拟机通过[对象头](./04_对象内存模型.md#对象内存结构)的Mark Word的信息来区分锁的状态：

![](../images/suo.png)

- 分代年龄占4bit：最大15，对象最大年龄为15；
- Epoch：偏向时间戳

# JIT对锁的优化

## 锁消除

编译期间，如果发现同步代码是不存在竞争的，或者只会存在一个线程执行，就会对锁进行消除；

- 锁消除是由JIT的逃逸分析完成的；

## 锁粗化

JIT动态编译时，发现方法内的多个同步代码可以合并，而不需要多次加锁时，会进行锁粗化合并，减少频繁加锁、释放锁的过程；

# 锁升级过程

JDK1.6后，针对锁进行了优化，之前是全为重量级锁，优化为锁根据竞争程度的大小，会逐步升级锁；竞争的代价逐步升高：

- 锁记录空间：持锁线程会在栈帧中记录，记录着锁对象的Mark Word信息；

- Mark Word：对象锁在Mark Word中记录此时**锁的状态**、**被哪个线程持有**等信息；

## 锁升级
1、偏向锁：无竞争，不需要CAS和加锁；

2、轻量级锁：竞争小，一般只需要CAS，不需要同步加锁，可避免上下文切换；同步加锁需要进行上下文切换，在内核态完成加锁、阻塞、唤醒等操作；

3、重量级锁：竞争大，需要同步竞争锁，失败则等待，锁释放触发唤醒；


## 偏向锁

偏向锁：在只有一个线程执行同步块的情况下，进一步提高性能，此线程将不需要执行同步操作，也不需要CAS操作，因为判定为只有一个线程，直接执行同步代码；

偏向锁的获取过程：

1. 在对象第一次被线程获取的时候，查看Mark Word中偏向锁标志是否为1，锁标志是否为01。是否已经确定Thread ID，如果已经确定，则不需要CAS操作，直接执行同步代码块。
2. 如果没有确定Thread ID，则通过CAS操作竞争锁，成功：则将Mark Word中的Thread ID设置为当前线程ID，然后执行同步代码块；
3. 如果竞争失败：则说明有线程一同竞争，偏向锁会触发撤销，并升级为轻量级锁。竞争失败的线程自旋。

偏向锁的撤销：

1、如果没有竞争，线程不会主动释放偏向锁；

2、当发生竞争，持锁线程停止在安全点，完成轻量级锁的升级，继续执行；

### 偏向锁的代价

偏向锁的**撤销代价很大**，当发现存在额外的线程竞争时，会尝试暂停当前持锁线程(需要达到安全点：执行结束、GC等)，然后撤销偏向锁，升级为轻量级锁，再继续执行当前线程；

理论上不需要偏向锁，大部分场景偏向锁都在徒增更多的代价；不如直接轻量级锁；

> 偏向锁的存在是历史原因，为了兼容旧版本的一些集合类，JDK15之后已经开始要消除偏向锁了；

JDK8默认开启偏向锁：`-XX:+UseBiasedLocking`

如果程序中大部分锁竞争一定会很激烈，可以设置为`-XX:-UseBiasedLocking`，关闭它；

## 轻量级锁

轻量级锁：针对锁竞争不严重，竞争的线程不需要挂起，自旋等待一会就可以获取锁，不涉及内核进行线程的挂起，减少了上下文的切换；

1. 虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间。
2. 将还没有被锁定的同步对象的对象头中的Mark Word拷贝到锁记录空间中
3. 拷贝成功后，使用CAS操作将对象头中的Mark Word修改为一个指针（指向此线程的锁记录空间）
4. 如果CAS操作成功，这个线程就拥有了该对象锁，并将锁标志“01”改为“00”，即表示此对象处于轻量级锁的状态。此时，如果有另一个线程竞争轻量级锁，则会发生**自旋**
5. 如果失败了，说明这个Mark Word已经被别的线程拿走了，自旋一定的次数后(默认10次)，依然无法获取轻量级锁，那么轻量级锁就会膨胀为重量级锁。锁标志则被修改为“10”。膨胀之后，不可逆转。变成重量级锁之后，其他竞争失败的线程不会自旋，而是**阻塞**。（大量线程自旋，极大浪费CPU）

![](../images/qingsuo.png)

解锁过程：

1. 依然是CAS操作，将上面被替换的Mark Word再替换回对象头中。
2. 替换失败，说明轻量级锁已经膨胀成了重量级锁，所以CAS操作替换失败，此时，一定有其他线程在抢夺锁的过程中被阻塞，这时候，释放锁的同事，唤醒被挂起的线程。

## 重量级锁

当自旋线程，自旋次数达到一定数量，被认为获取当前锁的自旋代价很高了，不如挂起；

但是阻塞和唤醒，需要从用户态转换为内核态，开销比较大；

那么就会触发锁升级为重量级锁；再次存在竞争时，直接挂起没有获取锁的线程；