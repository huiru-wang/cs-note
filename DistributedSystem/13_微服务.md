
- [微服务的目的](#微服务的目的)
- [微服务拆分](#微服务拆分)
  - [拆分原则](#拆分原则)
  - [拆分时机](#拆分时机)
- [开源解决方案](#开源解决方案)
- [1. 服务发现](#1-服务发现)
- [2. 服务通信RPC](#2-服务通信rpc)
  - [3. 负载均衡](#3-负载均衡)
  - [4. 服务监控](#4-服务监控)
    - [接口监控及告警](#接口监控及告警)
    - [监控](#监控)
    - [告警阈值](#告警阈值)
  - [5. 降级/熔断](#5-降级熔断)
    - [接口限流](#接口限流)
    - [服务降级](#服务降级)
      - [降级前明确](#降级前明确)
      - [降级触发点](#降级触发点)
      - [降级的实现](#降级的实现)
    - [熔断器](#熔断器)

# 微服务的目的
1、【**高内聚低耦合**】功能更加内聚，降低不同功能模块间的耦合；

2、【**故障隔离**】微服务间存在隔离性；可以通过降级、熔断等操作隔离微服务间的故障；

3、【**灵活扩展性强**】灵活度高、扩展性强；微服务模块独立部署、升级、动态扩缩容；每个微服务具备单一职责，可以独立升级上线；不需要跟随大版本；

4、【**可维护性高**】从代码结构上看，更容易优化；微服务的拆分本身就将业务进行了细化、内聚；代码维护上更加友好；

# 微服务拆分

## 拆分原则
1、**单一职责原则**；

- 按照业务领域垂直拆分；纵向依赖深度不要超过三层；服务间调用深度A -> B -> C；
  - 如电商业务中，用户相关的服务属于比较下层的通用服务，应该下沉拆分出来；
- 功能定位水平拆；
  - 如支付中台、订单中心、优惠券等功能定位不同，进行水平拆分；

2、**粒度应该适中**：不可太细，尽可能按照需求的演进迭代来拆分；当某个模块的新增功能需求比较复杂，功能又比较独立，可以考虑拆分；

3、**避免环形依赖**：会使得后期升级、部署维护更难；尽可能按照单向依赖拆分；

4、通用功能模块能力下沉；多模块共同依赖的服务功能应该进行下沉，再拆分；

## 拆分时机

不应该为了拆而拆，而应该是业务驱动、痛点驱动；

业务的规模发展到一定程度，已经到了一定的瓶颈，确实需要进行服务的拆分；

# 开源解决方案

Spring Cloud Alibaba + Dubbo(RPC) + Nacos(注册中心) + Sentinel(限流组件) + RocketMQ(消息总线)

文档：[Spring Cloud Alibaba](https://spring.io/projects/spring-cloud-alibaba)

SpringCloud：
- Feign：基于HTTP；通过配合Ribbon实现客户端负载均衡；
- Ribbon：客户端负载均衡；(随机、规则轮询、空闲策略)
- Histrix：熔断器；

Dubbo：
- RPC：支持多种协议(Duboo、Grpc、Triple)
- 自带负载均衡(随机、权重、最小活跃数)
- 服务提供方限流(默认令牌桶)
- 服务降级处理(通常Retry满后触发降级返回Mock埋点)

# 1. 服务发现

- 服务提供者：对外提供服务；
- 服务消费者：消费外部服务；
- 注册中心：存放和调度服务；将原本各个服务自行维护依赖的服务信息，解耦出来；并可以实现动态地监控、更新服务状态信息；

注册中心应该具备的基本能力：
- **心跳检测功能**：持续刷新注册的服务的状态；感知服务的上下线；保证服务间调用的畅通、容灾能力；
  - 通常下线功能，如果需要实时性高，需要客户端实现优雅下线，主动通知；
  - 感知下线后，应当能够通知依赖的服务；更新依赖服务的缓存；

- **服务注册能力**：应暴露接口使得服务提供者可用进行注册；
  - 客户端应当实现优雅启动，只有真正能够对外提供服务时，才注册到注册中心；

- **提供服务查询能力**：为服务消费方提供服务列表：让消费者感知依赖的服务信息；
- **高可用**：注册中心是服务间调用的核心，需要做高可用；

开源实现：

1、zookeeper(Zab)：CP架构；

2、Nacos(Raft)

- 配置中心：CP架构；
- 注册中心：AP架构；

3、Etcd(Raft)：CP架构；

# 2. 服务通信RPC

RPC框架的核心组件：
- 客户端：服务调用方；
- 服务端：服务提供方；
- 客户端存根：Client Stub；存储服务端的地址信息，序列化客户端的消息，发送给服务端；
- 服务端存根：Server Stub；接收客户端消息，反序列化消息，调用指定方法，返回；

一个RPC框架需要具备的功能：
- 高效的序列化；序列化的效率高，且序列化后的体积应该尽可能小；(protobuf、Hessian)
- 客户端负载均衡；
- 支持服务的降级、熔断；
- 支持请求重试、快速失败；
- 支持异步化；
- 支持接口的版本控制；
- 高效网络框架：如Netty；

## 3. 负载均衡

如Dubbo自带的客户端负载均衡；在微服务架构中，应当尽量使用客户端负载均衡；

如果仅有服务端负载均衡，如服务集群对外暴露Nginx，客户端会比较被动，遇到调用超时，只能继续调用，由服务端Nginx来做负载均衡；

## 4. 服务监控

治理：通过监控、限流、降低、熔断等方式，在突发情况、或触及性能瓶颈时保证核心业务的可用性，防止服务间连锁雪崩；

### 接口监控及告警

要做治理，首先要能监控到异常；

### 监控
1、接口实例监控；一般为微服务接口级别；

2、实例资源监控：微服务JVM、内存、CPU监控；

3、中间件的资源监控；

### 告警阈值

1、单接口响应时长阈值；

2、间隔内调用次数阈值；5min内调用次数；

## 5. 降级/熔断

降级/熔断都是需要在监控的基础上的；

### 接口限流

触发接口流量阈值之后，**只允许系统能够承担的流量访问**，保证业务的可用性，防止崩溃；

详见：[限流考量和设计](./13_限流设计.md)


### 服务降级

降级触发方式：
- 手动触发；通过动态配置开关，手动触发；
- 埋点降级：当服务不可用，重试超出次数后，客户端执行提前埋好的操作；
- 直接熔断：熔断是降级的一种策略，直接关闭非核心的业务；

#### 降级前明确
1、哪些是核心业务？哪些是非核心业务？

2、哪些接口允许降级？

3、确定后，明确降级策略，提前埋点；

#### 降级触发点

1、超时降级；

2、失败次数降级；

3、限流降级；

#### 降级的实现
可以通过切面来实现降级；

具体的降级策略，可以分离到单独模块，不耦合在原逻辑中；

针对特定的接口，需要实现特定的降级策略；

开源实现：FeignClient、Dubbo


### 熔断器

开源实现：Hystrix


