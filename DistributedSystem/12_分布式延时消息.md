

# 延时消息设计需要关注的点

1、持久化：保证消息是不会宕机丢失的；

2、可重试：在消费失败时可以重试，并可以重试多次后采用备选方案；

3、精度高：延时精度需要保证；


# 不合适的方案

## Redis过期监听

当Redis检查到key过期时，触发删除，并执行绑定的回调进行通知；

缺陷：
1、Redis检查Key是否过期使用：**定期随机扫描**、**惰性删除**；这两者都不一定在key过期时立即触发；

2、Redis回调通知后，立即删除key，不保证通知到达，更不保证通知正确处理；

## RabbitMQ死信队列
缺陷：

1、灵活度低：延迟时间是由队列决定的，不是由单个消息决定的；可能对于固定业务场景反而比较方便；

2、基于TTL机制，而非时间戳，重启可能造成延时重置；

3、必须安装RabbitMQ的延迟插件；

# 合适的方案

## RocketMQ、Pulsar定时投递功能
暂时没学过

## 基于Redis的Zset

zset中的score使用一个时间戳，客户端轮询zset，如果发现最小时间戳可以执行了，就执行；

## 基于DB定时轮询

1、由 单线程 定时轮询数据库(按照触发时间排序扫描，做好索引)

2、扫描间隔略小于消息延时最小精度即可；

3、扫描到的数据，根据特定字段，分发给特定的线程处理；

4、单线程获取执行结果：
- 任务完成：删除任务；
- 任务失败：标记失败次数，重新分发重试，达到一定次数，标记失败；

5、查询、分发、执行删除、标记失败次数等操作需要**保证耗时在延时精度范围内**；否则误差可能不断积累；