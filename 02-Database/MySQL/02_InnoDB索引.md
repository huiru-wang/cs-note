- [索引](#索引)
	- [InnoDB索引是如何实现的](#innodb索引是如何实现的)
	- [为什么是B+树](#为什么是b树)
		- [适合做索引的数据结构特点](#适合做索引的数据结构特点)
		- [对比候选数据结构](#对比候选数据结构)
		- [B+树特点](#b树特点)
	- [B+树查找过程](#b树查找过程)
	- [B+树存储数据量计算](#b树存储数据量计算)
- [InnoDB索引特点](#innodb索引特点)
- [InnoDB索引分类](#innodb索引分类)
	- [Clustered Indexes(聚簇索引)](#clustered-indexes聚簇索引)
	- [Secondary Indexes(辅助索引)](#secondary-indexes辅助索引)
		- [联合索引(多列索引)](#联合索引多列索引)
		- [唯一索引](#唯一索引)
	- [全文索引](#全文索引)
- [InnoDB索引行为](#innodb索引行为)
	- [索引覆盖](#索引覆盖)
	- [索引回表](#索引回表)
	- [最左前缀匹配](#最左前缀匹配)
	- [索引下推 ICP](#索引下推-icp)
		- [ICP条件](#icp条件)
		- [ICP执行过程](#icp执行过程)
- [索引膨胀/碎片/整理](#索引膨胀碎片整理)
# 索引

## InnoDB索引是如何实现的

索引本质就是针对数据建立的一种数据结构；

- B+树索引：**InnoDB引擎通过对指定的列，创建B+树的数据结构来实现索引，能够通过二分查找来加速数据查询；**
- Hash索引：InnoDB在读操作时会通过自适应hash索引，加速查询；
- 全文索引：

## 为什么是B+树

### 适合做索引的数据结构特点

1、必须是可排序的；可以利用二分搜索：**AVL树、B树、B+树、B*树**

2、查询时节点尽可能的少，降低IO，即多路搜索更佳：**B树、B+树、B*树**

### 对比候选数据结构

- **B树不可范围查询；**
- **B+树的叶子节点包含全量索引**；因此每次找到叶子节点，就可以获取数据；而B树每个节点都含有数据，遍历时对每个索引需要进行中序遍历(左-根-右)的方式保证顺序；
- B+树非叶子节点全部存储索引，能容纳更多索引；

AVL树、B树都存在数据量增大，树高增大过多、回溯查找的问题；

详见：[多叉排序树](../DS-Algorithm/Tree/3.%20%E5%A4%9A%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91.md)

### B+树特点

B+树目前来看是最优解：
- **索引高效**：B+树非叶子节点只存放索引，每页能够存储更多的索引，使得索引效率很高；
- **大量减少磁盘IO**：大部分的表结构，只需要建立3层B+树，最多只需要三次磁盘IO；
- **顺序性，支持范围查找**：叶子节点间是双向链表连接，叶子节点中具体的记录间是单向链表；

## B+树查找过程
1、将节点1加载进内存中，发生一次磁盘IO；
2、在内存中使用二分查找，确定索引列的位置，通过指针，找到下一个节点；
3、将下一个节点加载进内存，发生一次磁盘IO；以此类推；
4、直到最后找到叶子节点，加载进内存，发生一次磁盘IO，并找到索引对应的数据，读取数据；
因此三层B+树仅需三次磁盘IO，就能锁定数据；一般的表3层足矣；

## B+树存储数据量计算

假设非叶子节点只考虑记录头和索引，索引为BIGINT，占用8字节，每条数据1KB，一页存放16条数据；

那么：单页的索引数量 = 16KB / (记录头6字节 + 索引列占用大小8字节)

则：一页索引量：`16KB / 14Byte = 1170`

两层索引量为：`1170 x 1170 = 1368900`

三层B+树总数据量为：`1170 x 1170 x 16 = 21,9002,400`


# InnoDB索引特点
InnoDB索引的**B+树数据结构**中：
- 索引页默认：16K，由`innodb_page_size`设置；
- 索引页非操作系统PageCache的一页，通常为多页PageCache；

特点：

1、一张表有几个索引，就有几个B+树结构，最少一个；

2、每个节点就是一页InnoDB缓存页：[[OS/磁盘IO]]

3、节点类型
- 非叶子节点：存储当前B+树的索引信息；
- 叶子节点：存放具体的记录；记录间是单向链表，页间是双向链表；

4、数据的顺序性：**通过链表保证顺序的，但物理不连续，内存连续不能满足高效插入**；

- 叶子节点的数据是链表链接，就说明在磁盘上数据不是连续的；但是以页的方式加载进内存中，以顺序的方式关联；

4、索引类型
- 聚簇索引叶子节点：存放全量数据（如图主键索引）；
- 二级索引叶子节点：存放索引列 + 主键列的数据；

5、**非叶子节点的索引，都是按索引列进行排序的；不排序没法实现二分查找**；

6、主键尽可能递增，B+树顺序插入的性能是最高的；

# InnoDB索引分类
- 聚簇索引
- 二级索引
	- 唯一索引
	- 普通索引(单个非唯一索引)
	- 组合索引(联合索引)
- 全文索引

## Clustered Indexes(聚簇索引)
聚簇索引的叶子节点==包含所有列的数据==；
- 每张表只有一个聚簇索引(**主键**)；一般使用id标识每一条记录；
![单值索引](../../images/b+tree.png)

聚簇索引的创建：
- 当表设置了主键，即主键为聚簇索引；
- 当表没有主键，则第一个非空索引，设为聚簇索引；
- 当表没有任何索引，InnoDB会创建一个隐藏的row-id为聚簇索引；

## Secondary Indexes(辅助索引)
聚簇索引外的索引，统称为辅助索引；
- 辅助索引的叶子节点仅包含：==主键==；
- 如果查询结果需要索引列之外的数据，先查询到主键，再到主键B+树中查询其余数据(回表)

### 联合索引(多列索引)

![](../../images/union-index-2.png)

**多列的联合索引以Tuple的形式存储**，会按照索引顺序，先排序靠前的索引，再前一个索引下，再排序后一个索引；

这也是**联合索引有最左前缀匹配原则的原因**，即：只有前一个索引列确定的情况下，后一个索引才是有序的，才能够被使用；

因此，联合索引使用注意：

1、**尽量满足最左前缀匹配**
- `a = 1 AND b = 2`：满足；
- `a = 3`：满足；
- `b = 1 AND a = 1`：不满足，但是优化器通常会优化为ab；

2、**尽量将范围查询放在最后**

当 `a = 1 AND b = 2` 时，b才可能用到索引；
当 `a >=1 AND a <= 3 AND b = 2` 时，b是无序的，无法使用索引；

### 唯一索引
对某个或多个列创建唯一索引，则该列或多个列的值在整张表中保证唯一；

唯一索引效率高，因为不会有重复数据，在唯一索引B+树中，唯一的值锁定唯一的记录；

## 全文索引

可用使用全文索引的数据结构：


