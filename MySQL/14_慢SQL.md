
- [慢SQL的发现](#慢sql的发现)
- [慢SQL优化可以考虑的点](#慢sql优化可以考虑的点)
  - [如果是索引原因](#如果是索引原因)
  - [如果资源占用过多](#如果资源占用过多)
  - [如果数据库压力大](#如果数据库压力大)
  - [考虑业务的合理性](#考虑业务的合理性)

# 慢SQL的发现

1、慢SQL监控；

2、从接口响应延迟大，到定位到慢SQL；


# 慢SQL优化可以考虑的点

1、SQL本身没走索引慢；

2、SQL资源占用大；
- 数据量过大

## 如果是索引原因

SQL本身没有使用索引、没有选择合适的索引，导致的SQL慢：使用**Explain分析SQL执行计划**；

1、如果没有使用索引；
- 建立索引：不光要针对此SQL，还需要关注使用此表的其他SQL，如果有类似的查询条件，一起建立何时的索引，必要时调整SQL的查询条件；**尽量减少索引的数量**；

2、索引失效；
- 见：[索引失效场景](./04_InnoDB索引使用.md#索引失效场景)

3、对已经使用索引的情况，进一步优化；
- 见：[索引优化场景](./04_InnoDB索引使用.md#索引优化场景)

4、避免深分页，分页场景的慢SQL进行优化；
- 见：[深分页场景优化](./13_深分页.md)

5、排序场景

**如果 `order by` 后是单列索引，`order by`字段和`where`字段需要一致，否则会出现using filesort，无法使用索引排序**；

**如果 `order by` 后是联合索引，排序字段需要放在索引组合最后**；

## 如果资源占用过多
1、大事务占用过长；影响并发度；
- 对事务进行优化，必要时再开启事务；

2、谨慎使用`for update`；

3、增删改，务必走索引；

## 如果数据库压力大

1、查询数据量过大：行数过大、列数过多；
- 是否需要这么多列，尽量只查询需要的列；

2、单表数据量过大：分表、冷热分离等；

3、单实例QPS压力大：
- 分库分表，分摊压力；
- 读写分离；数据一致性要求不高的可以读从库，一致性要求比较高的可以读主库；


## 考虑业务的合理性

特殊业务，即使索引优化，也不能有很好的效果，是否可以采用别的方案？

1、like模糊查询，如果业务上需要，MySQL会显得无力，是否能选择搜索引擎方案；

2、热点数据，是否可以使用缓存；

3、NoSQL？