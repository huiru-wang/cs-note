
DDD是对高内聚低耦合思想的一种实现方法论，提供了一些思想，但是结合具体业务进行落地时，应当有所取舍，不可对照搬DDD方案无脑建模；

业务做领域拆分的方向是对的，但是拆分方案在不同的业务模型下很难设计把控，还是应当遵循面向对象设计的本质原则来进行设计；

但DDD领域驱动设计中有一些设计思想值得借鉴：

1、面向数据表对象编程  ---> 面向领域对象编程

2、充血模型，将领域模型的职责内聚；

3、领域下沉，更好复用，功能更内聚；

3、划分领域的信息和职责，更好地面向接口编程；

DDD设计思想很难落地的点：

0、非常依赖设计人员的功底；一开始领域的职责边界划分清晰还好，一旦设计不好，边界把控不好，代码结构将更加混乱，难以维护；

1、系统拆分层数过多，数据传递过程需要经过多次对象的转换；

2、**理想是领域向下沉淀，更好的被复用，上层服务只做编排工作**；实际开发甚至有交接，领域的理解有成本，很容易逐渐将大量业务放在上层服务中做；

3、领域的界限上下文的信息隐藏和膨胀；

# 分层结构

## 1. 用户接口层

B端/C端

## 2. 应用服务层

后端对外提供服务的接口层；MVC的Controller层；

## 3. 领域层

MVC的Service层，转为数据在不同的领域对象之间流转；
- 领域间职责划分需跟随业务，并且明确责任边界；
- 方法不再传递松散的基本数据类型，而是领域对象；接口的调用方不应关注具体的参数，而是关注传递的模型；更好的面向接口编程，依赖接口而非实现；

## 4. 基础设施层

为领域层提供接口服务，对外部依赖、数据访问等功能进行具体实现；
- ORM操作；
- 外部服务调用；
- 数据缓存层；
- 第三方工具实现、封装等；


# 贫血和充血模型
贫血模型：对象仅包含属性，不包含业务逻辑；
充血模型：Rich Domain Model，对象除了属性外，还拥有业务逻辑的部分职责；将模型本身相关的逻辑进行内聚；具体的充血程度，需要根据具体的业务对职责边界进行把控；

# 领域模型的状态
根据模型有无状态，将领域模型进行划分：
- Entity：带有唯一标识，具有状态的模型；
- DP(VO)：不具有状态；
